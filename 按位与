由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。
按位与（Bitwise AND），运算符号为&
a&b 的操作的结果：a、b中对应位同时为1，则对应结果位也为1、
例如：
10010001101000101011001111000
& 111111100000000
---------------------------------------------
10101100000000
对10101100000000进行右移8位得到的是101011，这就得到了a的8~15位的掩码了。那么根据这个启示，判断一个整数是否是处于 0-65535 之间（常用的越界判断）：
用一般的 (a >= 0) && (a <= 65535) 可能要两次判断。
改用位运算只要一次：
a & ~((1<< 16)-1)
后面的常数是编译时就算好了的。其实只要算一次逻辑与就行了。
 
  
  常用技巧：
   
   1、 用于整数的奇偶性判断
    
    一个整数a, a & 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数。使用a%2来判断奇偶性和a & 1是一样的作用，但是a & 1要快好多。
     
     2、 判断n是否是2的正整数冪
      
      (!(n&(n-1)) )&& n
       
       举个例子：
       如果n = 16 = 10000， n-1 = 1111
       那么：
       10000
       & 1111
       ----------
                  0
		  再举一个例子：如果n = 256 = 100000000， n-1 = 11111111
		  那么：
		  100000000
		  &11111111
		  --------------
		  0
		  好！看完上面的两个小例子，相信大家都有一个感性的认识。从理论上讲，如果一个数a他是2的正整数幂，那么a 的二进制形式必定为1000…..（后面有0个或者多个0），那么结论就很显然了。
		   
		   3、 统计n中1的个数
		    
		    朴素的统计办法是：先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到移位完毕。
		    朴素的统计办法是比较简单的，那么我们来看看比较高级的办法。
		     
		     举例说明，考虑2位整数 n=11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n=0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法。
		     在这里就顺便说一下常用的二进制数：
		     0xAAAAAAAA=10101010101010101010101010101010
		     0x55555555 = 1010101010101010101010101010101（奇数位为1，以1位为单位提取奇偶位）
		      
		      0xCCCCCCCC = 11001100110011001100110011001100
		      0x33333333 = 110011001100110011001100110011（以“2位”为单位提取奇偶位）
		       
		       0xF0F0F0F0 = 11110000111100001111000011110000
		       0x0F0F0F0F = 1111000011110000111100001111（以“8位”为单位提取奇偶位）
		        
			0xFFFF0000 =11111111111111110000000000000000
			0x0000FFFF = 1111111111111111（以“16位”为单位提取奇偶位）
			 
			 例如：32位无符号数的1的个数可以这样数：

			 int count_one(unsigned long n)
			 {
			 //0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位
			 n = ((n & 0xAAAAAAAA) >> 1) + (n & 0x55555555);

			 //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位
			 n = ((n & 0xCCCCCCCC) >> 2) + (n & 0x33333333);

			 //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位
			 n = ((n & 0xF0F0F0F0) >> 4) + (n & 0x0F0F0F0F);

			 //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位
			 n = ((n & 0xFF00FF00) >> 8) + (n & 0x00FF00FF);

			 //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位
			 n = ((n & 0xFFFF0000) >> 16) + (n & 0x0000FFFF);

			 return n;
			 }
			 举个例子吧，比如说我的生日是农历2月11，就用211吧，转成二进制：
			 n = 11010011
			 计算n = ((n & 0xAAAAAAAA) >> 1) + (n & 0x55555555);
			 得到 n = 10010010
			 计算n = ((n & 0xCCCCCCCC) >> 2) + (n & 0x33333333);
			 得到 n = 00110010
			 计算n = ((n & 0xF0F0F0F0) >> 4) + (n & 0x0F0F0F0F);
			 得到 n = 00000101 -----------------à无法再分了，那么5就是答案了。
			 4、对于正整数的模运算（注意，负数不能这么算）
			  
			  先说下比较简单的：
			  乘除法是很消耗时间的，只要对数左移一位就是乘以2，右移一位就是除以2，传说用位运算效率提高了60%。
			  乘2^k众所周知： n<<k。所以你以后还会傻傻地去敲2566*4的结果10264吗？直接2566<<4就搞定了，又快又准确。
			   
			   除2^k众所周知： n>>k。
			    
			    那么 mod 2^k 呢？（对2的倍数取模）
			    n&((1<<k)-1)
			    用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。
			    好！方便理解就举个例子吧。
			    思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？
			     
			     在此很容易让人想到快速幂取模法。
			     快速幂取模算法
			     经常做题目的时候会遇到要计算 a^b mod c 的情况，这时候，一个不小心就TLE了。那么如何解决这个问题呢？位运算来帮你吧。
			      
			      首先介绍一下秦九韶算法：(数值分析讲得很清楚)
			      把一个n次多项式f(x) = a[n]x^n+a[n-1]x^(n-1)+......+a[1]x+a[0]改写成如下形式：
			      　　f(x) = a[n]x^n+a[n-1]x^(n-1))+......+a[1]x+a[0]
			      　　= (a[n]x^(n-1)+a[n-1]x^(n-2)+......+a[1])x+a[0]
			      　　= ((a[n]x^(n-2)+a[n-1]x^(n-3)+......+a[2])x+a[1])x+a[0]
			      　　=. .....
			      　　= (......((a[n]x+a[n-1])x+a[n-2])x+......+a[1])x+a[0].
			      　　求多项式的值时，首先计算最内层括号内一次多项式的值，即
			      　　v[1]=a[n]x+a[n-1]
			      　　然后由内向外逐层计算一次多项式的值，即
			      　　v[2]=v[1]x+a[n-2]
			      　　v[3]=v[2]x+a[n-3]
			      　　......
			      　　v[n]=v[n-1]x+a[0]
			      这样，求n次多项式f(x)的值就转化为求n个一次多项式的值。
			       
			       好！有了前面的基础知识，我们开始解决问题吧
			       由(a ×b) mod c=( (a mod c) × b) mod c.
			       我们可以将 b先表示成就：
			       b = a[t] × 2^t + a[t-1]× 2^(t-1) + …… + a[0] × 2^0. (a[i]=[0,1]).
			       这样我们由 a^b mod c = (a^(a[t] × 2^t + a[t-1]× 2^（t-1） + …a[0] × 2^0) mod c.
			       然而我们求 a^( 2^(i+1) ) mod c=( (a^(2^i)) mod c)^2 mod c .求得。
			       具体实现如下：
			       使用秦九韶算法思想进行快速幂模算法，简洁漂亮
			       // 快速计算 (a ^ p) % m 的值
			       __int64 FastM(__int64 a, __int64 p, __int64 m)
			       {
			       if (p == 0) return 1;
			       __int64 r = a % m;
			       __int64 k = 1;
			       while (p > 1)
			       {
			       if ((p & 1)!=0)
			       {
			       k = (k * r) % m;
			       }
			       r = (r * r) % m;
			       p >>= 1;
			       }
			       return (r * k) % m;
			       }
			       http://acm.pku.edu.cn/JudgeOnline/problem?id=3070
			        
				5、计算掩码
				比如一个截取低6位的掩码：0×3F
				用位运算这么表示：(1<< 6) - 1
				这样也非常好读取掩码，因为掩码的位数直接体现在表达式里。
				按位或运算很简单，只要a和b中相应位出现1，那么a|b的结果相应位也为1。就不多说了。
				6、子集
				　　枚举出一个集合的子集。设原集合为mask，则下面的代码就可以列出它的所有子集：


				　　for (i = mask ; i ; i = (i - 1) & mask) ;
